---
output: html_document
editor_options: 
  chunk_output_type: console
---


```{r}

```


```{r}
library(readr)
library(RSQLite)
library(tibble) 
library(dplyr) 
library(lubridate)
library(DBI)
library(assertthat)
library(purrr)
```



Part 1.2 - SQL Database Schema Creation 

```{r}

setwd("/cloud/project/")

#connect to the SQLite database
my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")


dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS CUSTOMERS
                (   
                    customer_id VARCHAR(255) NOT NULL PRIMARY KEY,
                    first_name VARCHAR(255) NOT NULL,
                    last_name VARCHAR(255),
                    username VARCHAR(255),
                    gender TEXT,
                    date_of_birth DATE NOT NULL,
                    email VARCHAR(255) UNIQUE,
                    phone VARCHAR(20) UNIQUE,
                    street_name VARCHAR(255),
                    city VARCHAR(255),
                    country VARCHAR(255),
                    zip_code VARCHAR(20),
                    account_created_date TIMESTAMP,
                    premium_subscription INTEGER
                );"
          )

dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS PRODUCT_CATEGORY
                (
                    category_id VARCHAR(255) NOT NULL PRIMARY KEY,
                    cat_name VARCHAR(255)
                );"
          )
dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS PRODUCTS
                (
                    product_id VARCHAR(255) NOT NULL PRIMARY KEY,
                    product_name VARCHAR(255),
                    price REAL,
                    stock_quantity INTEGER NOT NULL,
                    category_id VARCHAR(255) NOT NULL,
                    supplier_id VARCHAR(255) NOT NULL,
                    FOREIGN KEY(category_id) REFERENCES PRODUCT_CATEGORY(category_id),
                    FOREIGN KEY(supplier_id) REFERENCES SUPPLIERS(supplier_id)
                );"
          )
dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS SUPPLIERS
                (
                    supplier_id VARCHAR(255) NOT NULL PRIMARY KEY,
                    supplier_name VARCHAR(255),
                    supplier_address VARCHAR(500),
                    supplier_phone VARCHAR(20),
                    supplier_email VARCHAR(255) UNIQUE
                );"
          )
dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS GIFT_CARD
                (
                gift_card_id VARCHAR(50) NOT NULL PRIMARY KEY,
                gift_card_code VARCHAR(50),
                detail INTEGER,
                status VARCHAR(50)
                );"
          )
dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS ORDERS
                (
                    order_id VARCHAR(255) NOT NULL PRIMARY KEY,
                    customer_id VARCHAR(255),
                    product_id VARCHAR(255),
                    shipment_id VARCHAR(255),
                    gift_card_id VARCHAR(255), 
                    payment_method TEXT,
                    quantity INTEGER,
                    order_timestamp TIMESTAMP,
                    payment_timestamp TIMESTAMP,
                    order_status VARCHAR(50) NOT NULL,
                    amount REAL,
                    FOREIGN KEY(customer_id) REFERENCES CUSTOMERS(customer_id),
                    FOREIGN KEY(product_id) REFERENCES PRODUCTS(product_id),
                    FOREIGN KEY(shipment_id) REFERENCES SHIPMENT(shipment_id), 
                    FOREIGN KEY(gift_card_id) REFERENCES GIFT_CARD(gift_card_id) 
                );"
          )
dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS SHIPMENT
                (
                shipment_id VARCHAR(255) NOT NULL PRIMARY KEY,
                order_id VARCHAR(255),
                dispatch_timestamp DATETIME,
                shipped_timestamp DATETIME,
                status VARCHAR(50) NOT NULL,
                FOREIGN KEY(order_id) REFERENCES ORDERS(order_id)
                );"
          )

#Check if the tables are created

dbGetQuery(my_connection, 
    sprintf("SELECT name FROM sqlite_master WHERE type='table';")
  )


# dbDisconnect(my_connection)


```

#Generate Data

```{r}

customers_df <- readr::read_csv("datasets/CUSTOMERS.csv")
products_df <- readr::read_csv("datasets/PRODUCTS.csv")
gift_card_df <- readr::read_csv("datasets/GIFT_CARDS.csv")
category_df <- readr::read_csv("datasets/CATEGORY.csv")
suppliers_df <- readr::read_csv("datasets/SUPPLIERS.csv") 

#Sample Customers

sample_size <- floor(0.2 * nrow(products_df))
sampled_product_ids <- sample(products_df$product_id, size = sample_size, replace = FALSE)
sampled_products_df <- products_df[products_df$product_id %in% sampled_product_ids, ]


#Sample Products

sample_size <- floor(0.2 * nrow(customers_df))
sampled_customer_ids <- sample(customers_df$customer_id, size = sample_size, replace = FALSE)
sampled_customers_df <- customers_df[customers_df$customer_id %in% sampled_customer_ids, ]


generate_orders_data <- function(n = 1000) {
  set.seed(123) 
  
  orders_df <- tibble(
    order_id = sprintf("%s-%04d", "ORD", 1:n),
    customer_id = sample(sampled_customers_df$customer_id, n, replace = TRUE),
    product_id = sample(sampled_products_df$product_id, n, replace = TRUE),
    gift_card_id = sample(c(NA, gift_card_df$gift_card_id), n, replace = TRUE), # Assuming gift cards are used as discounts
    payment_method = sample(c("Credit Card", "Debit Card", "PayPal", "Gift Card"), n, replace = TRUE),
    quantity = sample(1:5, n, replace = TRUE),
    order_timestamp = sample(seq(as.POSIXct('2024/02/01'), as.POSIXct('2024/02/29'), by="day"), n, replace = TRUE),
    payment_timestamp = order_timestamp + hours(sample(1:72, n, replace = TRUE)), # Payment within 1 to 72 hours after order
    order_status = sample(c("Processing", "Shipped", "Delivered", "Cancelled","Pending Payment","Out for Delivery"), n, replace = TRUE),
    amount = round(runif(n, 50, 500), 2) # Random amount between $50 and $500
  )
  
  # Augment the orders data frame with supplier_id using left_join
  orders_df <- orders_df %>%
    left_join(sampled_products_df %>% select(product_id, supplier_id), by = "product_id") %>%
    select(order_id, customer_id, product_id, gift_card_id, payment_method, quantity, order_timestamp, payment_timestamp, order_status, amount, supplier_id)
  
  return(orders_df)
}

# Generate orders data
orders_df <- generate_orders_data(n = 1000)

generate_shipment_ids <- function(df) {
  # Create a unique identifier for each group
  df <- df %>% 
    mutate(date_only = as.Date(order_timestamp)) %>% 
    group_by(customer_id, supplier_id, date_only) %>%
    mutate(shipment_group_id = cur_group_id()) %>%
    ungroup() %>%
    mutate(shipment_id = sprintf("SHIP%05d", shipment_group_id)) %>%
    select(-shipment_group_id, -date_only) # Clean up the extra columns
  
  df
}

# Apply the function to your data frame
orders_df <- generate_shipment_ids(orders_df)

# Optional: Adjusting for logical consistency (e.g., cancelled orders should not have a shipment_id)
  orders_df <- orders_df %>%
    mutate(shipment_id = if_else(order_status %in% c("Cancelled","Pending Payment"), NA_character_,
                                 as.character(shipment_id)),
           payment_method = if_else(order_status == "Pending Payment",NA_character_,payment_method)) %>%
    mutate(supplier_id = NULL)
```


```{r}
#Shipment Table
  
  shipment_df <- orders_df %>%
    mutate(
      # Dispatch date could be the same as the order date or a day after
      dispatch_timestamp = order_timestamp + days(sample(0:1, n(), replace = TRUE)),
      
      # Delivered date should be after the dispatch date; here I assume delivery takes between 2 to 5 days
      delivered_timestamp = dispatch_timestamp + days(sample(2:5, n(), replace = TRUE)),
      
      # Randomly assign a delivery status
      status = if_else(order_status == "Processing","Ready for Dispatch",if_else(order_status == "Shipped","In Transit",if_else(order_status == "Out for Delivery",order_status,if_else(order_status == "Delivered",order_status,"NA"))))
    ) %>%
    # Select only the relevant columns for the shipment table
    select(shipment_id, dispatch_timestamp, delivered_timestamp, status) %>%
    # Remove duplicate rows to ensure unique shipments
    distinct() 

  shipment_df <- na.omit(shipment_df)
  
  
  shipment_df <- shipment_df %>%
    mutate(
      # Assign NA to dispatch_timestamp if status is 'Ready for Dispatch'
      dispatch_timestamp = if_else(status == "Ready for Dispatch", NA_Date_, dispatch_timestamp),
      delivered_timestamp = if_else(status == "Ready for Dispatch", NA_Date_, delivered_timestamp),
      
      # 'In Transit' status should have a dispatch date but no delivery date
      dispatch_timestamp = if_else(status == "In Transit", Sys.Date() - days(sample(1:5, 1)), dispatch_timestamp),
      delivered_timestamp = if_else(status == "In Transit", NA_Date_, delivered_timestamp),
      
      # 'In Transit' status should have a dispatch date but no delivery date
      dispatch_timestamp = if_else(status == "Out for Delivery", Sys.Date() - days(sample(1:5, 1)), dispatch_timestamp),
      delivered_timestamp = if_else(status == "Out for Delivery", NA_Date_, delivered_timestamp),
      
      # If status is 'Delivered', both dates should be in the past, with delivered after dispatched
      dispatch_timestamp = if_else(status == "Delivered" & is.na(dispatch_timestamp), Sys.Date() - days(sample(6:10, 1)), dispatch_timestamp),
      delivered_timestamp = if_else(status == "Delivered", dispatch_timestamp + days(sample(1:5, 1)), delivered_timestamp)
    )
  
write_csv(orders_df,"datasets/ORDERS.csv")

write_csv(shipment_df,"datasets/SHIPMENTS.csv")


```

Data Validation and Ingestion

1.CUSTOMERS

```{r}
ingest_customer_data <- function(df, my_connection) {

  # Data validation

  #email check
  valid_email <- grepl("^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$", df$email)
  df <- df[valid_email, ]
  
  #gender check
  valid_genders <- c("Male", "Female", "Other")
  df <- df[df$gender %in% valid_genders, ]
  

  # Data type checks (adjust according to your data frame)
  df$date_of_birth <- as.Date(df$date_of_birth,format = "%d/%m/%y")
  df$account_created_date <- as.Date(df$account_created_date,format = "%d/%m/%y")
  df$premium_subscription <- as.integer(df$premium_subscription)
  
  # Check for null values in NOT NULL columns
  required_columns <- c("customer_id", "first_name", "date_of_birth")
  df <- df[!rowSums(is.na(df[required_columns])) > 0, ]
  
  # Insert validated data into the database
  for(i in 1:nrow(df)){
    
      #Check for duplicate records based on the primary key
   existing_ids <- dbGetQuery(my_connection, sprintf("SELECT customer_id FROM CUSTOMERS WHERE customer_id = '%s'",   df$customer_id[i]))
    if(nrow(existing_ids) > 0) {
      cat(sprintf("Skipping duplicate entry for customer_id: %s\n", df$customer_id[i]))
      next
    }
     
    insert_query <- sprintf("INSERT INTO CUSTOMERS (customer_id, first_name, last_name, username, gender, date_of_birth, email, phone, street_name, city, country, zip_code, account_created_date, premium_subscription)
                            VALUES ('%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', %d)",
                            df$customer_id[i], df$first_name[i], df$last_name[i], df$username[i], df$gender[i], df$date_of_birth[i],
                            df$email[i], df$phone[i], df$street_name[i], df$city[i], df$country[i], df$zip_code[i], df$account_created_date[i], df$premium_subscription[i])
    tryCatch({
  dbExecute(my_connection, insert_query)
  cat(sprintf("Successfully inserted row: %d\n", i))
}, error = function(e) {
  cat(sprintf("Error in inserting row: %d, Error: %s\n", i, e$message))
})
  }

  # Close the database connection
  dbDisconnect(my_connection)
}
my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
ingest_customer_data(customers_df, my_connection)

```

```{r}
my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
dbGetQuery(my_connection,"SELECT * FROM CUSTOMERS;")
```


```{r}
dbExecute(my_connection,"DELETE FROM CUSTOMERS;")
```

2. PRODUCT_CATEGORY 

```{r}
ingest_product_category <- function(df, my_connection) {
  # Check for null values in NOT NULL columns
  required_columns <- c("category_id", "cat_name")
  df <- df[!rowSums(is.na(df[required_columns])) > 0, ]
  
  # Insert validated data into the database
  for(i in 1:nrow(df)){
    # Check for duplicate records based on the primary key
    existing_ids <- dbGetQuery(my_connection, sprintf("SELECT category_id FROM PRODUCT_CATEGORY WHERE category_id = '%s'", df$category_id[i]))
    if(nrow(existing_ids) > 0) {
      cat(sprintf("Skipping duplicate entry for category_id: %s\n", df$category_id[i]))
      next
    }
    
    insert_query <- sprintf("INSERT INTO PRODUCT_CATEGORY (category_id, cat_name) VALUES ('%s', '%s')",
                            df$category_id[i], df$cat_name[i])
    tryCatch({
      dbExecute(my_connection, insert_query)
      cat(sprintf("Successfully inserted row: %d\n", i))
    }, error = function(e) {
      cat(sprintf("Error in inserting row: %d, Error: %s\n", i, e$message))
    })
  }
}

my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
ingest_product_category(category_df, my_connection)

```


```{r}
my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
dbGetQuery(my_connection,"SELECT * FROM PRODUCT_CATEGORY;")
```


```{r}
#dbExecute(my_connection,"DELETE FROM PRODUCT_CATEGORY;")
```

3.PRODUCTS

```{r}
ingest_products <- function(df, my_connection) {
  # Data type checks
  df$price <- as.numeric(df$price)
  df$stock_quantity <- as.integer(df$stock_quantity)
  
  # Check for null values in NOT NULL columns
  required_columns <- c("product_id", "stock_quantity", "category_id", "supplier_id")
  df <- df[!rowSums(is.na(df[required_columns])) > 0, ]
  
  for(i in 1:nrow(df)){
    # Check for duplicate records based on the primary key and foreign key constraints
    existing_product_ids <- dbGetQuery(my_connection, sprintf("SELECT product_id FROM PRODUCTS WHERE product_id = '%s'", df$product_id[i]))
    if(nrow(existing_product_ids) > 0) {
      cat(sprintf("Skipping duplicate entry for product_id: %s\n", df$product_id[i]))
      next
    }
    
    # Construct and execute the insertion query
    insert_query <- sprintf("INSERT INTO PRODUCTS (product_id, product_name, price, stock_quantity, category_id, supplier_id) VALUES ('%s', '%s', %f, %d, '%s', '%s')",
                            df$product_id[i], df$product_name[i], df$price[i], df$stock_quantity[i], df$category_id[i], df$supplier_id[i])
    tryCatch({
      dbExecute(my_connection, insert_query)
      cat(sprintf("Successfully inserted row: %d\n", i))
    }, error = function(e) {
      cat(sprintf("Error in inserting row: %d, Error: %s\n", i, e$message))
    })
  }
}

my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
ingest_products(products_df, my_connection)
```

```{r}
my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
dbGetQuery(my_connection,"SELECT * FROM PRODUCTS;")
```


```{r}
#dbExecute(my_connection,"DELETE FROM PRODUCTS;")
```


SUPPLIERS

```{r}
ingest_suppliers <- function(df, my_connection) {
  # Email format validation
  valid_email <- grepl("^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$", df$supplier_email)
  df <- df[valid_email, ]
  
  # Check for null values in NOT NULL columns
  required_columns <- c("supplier_id", "supplier_name")
  df <- df[!rowSums(is.na(df[required_columns])) > 0, ]
  
  for(i in 1:nrow(df)){
    # Check for duplicate records based on the primary key
    existing_supplier_ids <- dbGetQuery(my_connection, sprintf("SELECT supplier_id FROM SUPPLIERS WHERE supplier_id = '%s'", df$supplier_id[i]))
    if(nrow(existing_supplier_ids) > 0) {
      cat(sprintf("Skipping duplicate entry for supplier_id: %s\n", df$supplier_id[i]))
      next
    }
    
    insert_query <- sprintf("INSERT INTO SUPPLIERS (supplier_id, supplier_name, supplier_address, supplier_phone, supplier_email) VALUES ('%s', '%s', '%s', '%s', '%s')",
                            df$supplier_id[i], df$supplier_name[i], df$supplier_address[i], df$supplier_phone[i], df$supplier_email[i])
    tryCatch({
      dbExecute(my_connection, insert_query)
      cat(sprintf("Successfully inserted row: %d\n", i))
    }, error = function(e) {
      cat(sprintf("Error in inserting row: %d, Error: %s\n", i, e$message))
    })
    
  }
}

my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
ingest_suppliers(suppliers_df, my_connection)

```


```{r}
my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
dbGetQuery(my_connection,"SELECT * FROM SUPPLIERS;")
```

```{r}
#Test Abi
```




```{r}
#dbExecute(my_connection,"DELETE FROM SUPPLIERS;")
```




1. Top 10 Products - Overall (Quantity)
2. Top 5 Categories (Quantity)
3. Top 3 Products across categories (Total Amount)
4. Average delivery time for orders across top 5 delivery suppliers
```{r}
# Join orders with products to get category information
orders_with_category <- orders_df %>%
  inner_join(products_df, by = "product_id")

# Calculate total amount for each product
product_amounts <- orders_with_category %>%
  group_by(category_id, product_id, product_name) %>%
  summarise(total_amount = sum(quantity * amount, na.rm = TRUE)) %>%
  ungroup()

# Join with category_df to get category names
product_amounts_with_category_name <- product_amounts %>%
  inner_join(category_df, by = "category_id")

# Get overall top 3 products
top_3_products <- product_amounts_with_category_name %>%
  arrange(desc(total_amount)) %>%
  slice_max(total_amount, n = 3) %>%
  ungroup()

# Plot using ggplot2
ggplot(top_3_products, aes(x = reorder(product_name, total_amount), y = total_amount, fill = cat_name)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  coord_flip() +
  labs(title = "Top 3 Products by Total Amount",
       x = "Product Name",
       y = "Total Amount") +
  theme_minimal() +
  theme(legend.title = element_text(size = 12),
        legend.text = element_text(size = 10))
```


5. Top 20 Average Spending across customers
6. Most cancelled orders for which category
7. Average number of orders across time
8. Scatter plot for revenue across quantity; color by category