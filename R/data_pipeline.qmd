---
output: html_document
editor_options: 
  chunk_output_type: console
---


```{r}
library(readr)
library(RSQLite)
library(tibble) 
library(dplyr) 
library(lubridate)
#library(ggplot2)
library(DBI)
install.packages("tidyr")
library(tidyr)
```


Part 1.2 - SQL Database Schema Creation 


```{r}

setwd("/cloud/project/")

#connect to the SQLite database
my_connection <- RSQLite::dbConnect(RSQLite::SQLite()
                                    , "database/ecommerce_database_v1.db")


dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS CUSTOMERS
                (   
                    customer_id VARCHAR(255) NOT NULL PRIMARY KEY,
                    first_name VARCHAR(255) NOT NULL,
                    last_name VARCHAR(255),
                    username VARCHAR(255),
                    gender TEXT,
                    date_of_birth DATE NOT NULL,
                    email VARCHAR(255) UNIQUE,
                    phone VARCHAR(20) UNIQUE,
                    street_name VARCHAR(255),
                    city VARCHAR(255),
                    country VARCHAR(255),
                    zip_code VARCHAR(20),
                    account_created_date TIMESTAMP,
                    premium_subscription INTEGER
                );"
          )

dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS PRODUCT_CATEGORY
                (
                    category_id VARCHAR(255) NOT NULL PRIMARY KEY,
                    cat_name VARCHAR(255)
                );"
          )

dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS SUPPLIERS
                (
                    supplier_id VARCHAR(255) NOT NULL PRIMARY KEY,
                    supplier_name VARCHAR(255),
                    supplier_address VARCHAR(500),
                    supplier_phone VARCHAR(20),
                    supplier_email VARCHAR(255) UNIQUE
                );"
          )

dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS PRODUCTS
                (
                    product_id VARCHAR(255) NOT NULL PRIMARY KEY,
                    product_name VARCHAR(255),
                    price REAL,
                    stock_quantity INTEGER NOT NULL,
                    category_id VARCHAR(255) NOT NULL,
                    supplier_id VARCHAR(255) NOT NULL,
                    FOREIGN KEY(category_id) 
                    REFERENCES PRODUCT_CATEGORY(category_id),
                    FOREIGN KEY(supplier_id) REFERENCES SUPPLIERS(supplier_id)
                );"
          )

dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS GIFT_CARD
                (
                gift_card_id VARCHAR(50) NOT NULL PRIMARY KEY,
                gift_card_code VARCHAR(50),
                detail INTEGER,
                status VARCHAR(50)
                );"
          )
dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS ORDERS
                (
                    order_id VARCHAR(255) NOT NULL PRIMARY KEY,
                    customer_id VARCHAR(255),
                    product_id VARCHAR(255),
                    gift_card_id VARCHAR(255), 
                    payment_method TEXT,
                    quantity INTEGER,
                    order_timestamp TIMESTAMP,
                    payment_timestamp TIMESTAMP,
                    order_status VARCHAR(50) NOT NULL,
                    shipment_id VARCHAR(255),
                    FOREIGN KEY(customer_id) REFERENCES CUSTOMERS(customer_id),
                    FOREIGN KEY(product_id) REFERENCES PRODUCTS(product_id),
                    FOREIGN KEY(shipment_id) REFERENCES SHIPMENT(shipment_id), 
                    FOREIGN KEY(gift_card_id) REFERENCES GIFT_CARD(gift_card_id) 
                );"
          )
dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS SHIPMENT
                (
                shipment_id VARCHAR(255) NOT NULL PRIMARY KEY,
                dispatch_timestamp DATETIME,
                delivered_timestamp DATETIME,
                status VARCHAR(50) NOT NULL
                );"
          )

#Check if the tables are created

dbGetQuery(my_connection, 
    sprintf("SELECT name FROM sqlite_master WHERE type='table';")
  )


# dbDisconnect(my_connection)


```

#Generate Data

```{r}
## Find all files matching the pattern
customer_files <- list.files(path = "datasets"
                             ,pattern = "CUSTOMERS.*\\.csv$",full.names = TRUE )
category_files <- list.files(path = "datasets"
                             ,pattern = "CATEGORY.*\\.csv$",full.names = TRUE )
gift_card_files <- list.files(path = "datasets"
                              ,pattern = "GIFT_CARDS.*\\.csv$",full.names = TRUE )
suppliers_files <- list.files(path = "datasets"
                              ,pattern = "SUPPLIERS.*\\.csv$",full.names = TRUE )
products_files <- list.files(path = "datasets"
                             ,pattern = "PRODUCTS.*\\.csv$",full.names = TRUE )

customers_df <- readr::read_csv(customer_files[1])
gift_card_df <- readr::read_csv(gift_card_files[1])
suppliers_df <- readr::read_csv(suppliers_files[1])
category_df <- readr::read_csv(category_files[1]) 
products_df <- readr::read_csv(products_files[1])



#Sample Customers

sample_size <- floor(0.2 * nrow(products_df))
sampled_product_ids <- sample(products_df$product_id
                              , size = sample_size, replace = FALSE)
sampled_products_df <- products_df[products_df$product_id 
                                   %in% sampled_product_ids, ]


#Sample Products

sample_size <- floor(0.2 * nrow(customers_df))
sampled_customer_ids <- sample(customers_df$customer_id
                               , size = sample_size, replace = FALSE)
sampled_customers_df <- customers_df[customers_df$customer_id 
                                     %in% sampled_customer_ids, ]


generate_orders_data <- function(n = 1000) {
  set.seed(123) 
  
  orders_df <- tibble(
    order_id = sprintf("%s-%04d", "ORD", 1:n),
    customer_id = sample(sampled_customers_df$customer_id, n, replace = TRUE),
    product_id = sample(sampled_products_df$product_id, n, replace = TRUE),
    gift_card_id = sample(c(NA, gift_card_df$gift_card_id), n, replace = TRUE)
    , # Assuming gift cards are used as discounts
    payment_method = sample(c("Credit Card", "Debit Card"
                              , "PayPal", "Gift Card"), n, replace = TRUE),
    quantity = sample(1:5, n, replace = TRUE),
    order_timestamp = sample(seq(as.POSIXct('2024/02/01')
                                 , as.POSIXct('2024/02/29'), by="day")
                             , n, replace = TRUE),
    payment_timestamp = order_timestamp + hours(sample(1:72, n, replace = TRUE)),
    order_status = sample(c("Processing", "Shipped", "Delivered"
                            , "Cancelled","Pending Payment","Out for Delivery")
                          , n, replace = TRUE),
  )
  
  # Augment the orders data frame with supplier_id using left_join
  orders_df <- orders_df %>%
    left_join(sampled_products_df %>% select(product_id, supplier_id)
              , by = "product_id") %>%
    select(order_id, customer_id, product_id, gift_card_id, payment_method
           , quantity, order_timestamp, payment_timestamp
           , order_status, supplier_id)
  
  return(orders_df)
}

# Generate orders data
orders_df <- generate_orders_data(n = 1000)

generate_shipment_ids <- function(df) {
  # Create a unique identifier for each group
  df <- df %>% 
    mutate(date_only = as.Date(order_timestamp)) %>% 
    group_by(customer_id, supplier_id, date_only) %>%
    mutate(shipment_group_id = cur_group_id()) %>%
    ungroup() %>%
    mutate(shipment_id = sprintf("SHIP%05d", shipment_group_id)) %>%
    select(-shipment_group_id, -date_only) # Clean up the extra columns
  
  df
}

# Apply the function to your data frame
orders_df <- generate_shipment_ids(orders_df)

# Optional: Adjusting for logical consistency (e.g., 
# cancelled orders should not have a shipment_id)
  orders_df <- orders_df %>%
    mutate(shipment_id = if_else(order_status %in% 
                                   c("Cancelled","Pending Payment")
                                 , NA_character_,as.character(shipment_id)),
           payment_method = if_else(order_status == "Pending Payment"
                                    ,NA_character_,payment_method)) %>%
    mutate(supplier_id = NULL)
```


```{r}
#Shipment Table
  
  shipment_df <- orders_df %>%
    mutate(
      # Dispatch date could be the same as the order date or a day after
      dispatch_timestamp = order_timestamp + days(sample(0:1
                                                      , n(), replace = TRUE)),
      
      # Delivered date should be after the dispatch date; 
      #here I assume delivery takes between 2 to 5 days
      delivered_timestamp = dispatch_timestamp + days(sample(2:14
                                                    , n(), replace = TRUE)),
      
      # Randomly assign a delivery status
      status = if_else(order_status == "Processing","Ready for Dispatch"
              ,if_else(order_status == "Shipped","In Transit"
              ,if_else(order_status == "Out for Delivery",order_status
              ,if_else(order_status == "Delivered",order_status,"NA"))))
    ) %>%
    # Select only the relevant columns for the shipment table
    select(shipment_id, dispatch_timestamp, delivered_timestamp, status) %>%
    # Remove duplicate rows to ensure unique shipments
    distinct() 

  shipment_df <- na.omit(shipment_df)
  
  
  shipment_df <- shipment_df %>%
    mutate(
      # Assign NA to dispatch_timestamp if status is 'Ready for Dispatch'
      dispatch_timestamp = if_else(status == "Ready for Dispatch"
                                   , NA_Date_, dispatch_timestamp),
      delivered_timestamp = if_else(status == "Ready for Dispatch"
                                    , NA_Date_, delivered_timestamp),
      
      # 'In Transit' status should have a dispatch date but no delivery date
      dispatch_timestamp = if_else(status == "In Transit",
                                  Sys.Date() - days(sample(1:14, 1)), 
                                  dispatch_timestamp),
      delivered_timestamp = if_else(status == "In Transit"
                                    , NA_Date_, delivered_timestamp),
      
      # 'In Transit' status should have a dispatch date but no delivery date
      dispatch_timestamp = if_else(status == "Out for Delivery"
                                   , Sys.Date() - days(sample(1:14, 1))
                                   , dispatch_timestamp),
      delivered_timestamp = if_else(status == "Out for Delivery"
                                    , NA_Date_, delivered_timestamp)
    )
  
write_csv(orders_df,"datasets/ORDERS.csv")

write_csv(shipment_df,"datasets/SHIPMENTS.csv")


```

Data Validation and Ingestion

1.CUSTOMERS

```{r}
ingest_customer_data <- function(df) {
  
  my_connection <- RSQLite::dbConnect(RSQLite::SQLite()
                                      , "database/ecommerce_database_v1.db")
  # Data validation

  #email check
  valid_email <- grepl("^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
                       , df$email)
  df <- df[valid_email, ]
  
  #gender check
  valid_genders <- c("Male", "Female", "Other")
  df <- df[df$gender %in% valid_genders, ]
  

  # Data type checks (adjust according to your data frame)
  df$date_of_birth <- as.Date(df$date_of_birth,format = "%d/%m/%y")
  df$account_created_date <- as.Date(df$account_created_date,format = "%d/%m/%y")
  df$premium_subscription <- as.integer(df$premium_subscription)
  
  # Check for null values in NOT NULL columns
  required_columns <- c("customer_id", "first_name", "date_of_birth")
  df <- df[!rowSums(is.na(df[required_columns])) > 0, ]
  
  # Insert validated data into the database
  for(i in 1:nrow(df)){
    
      #Check for duplicate records based on the primary key
   existing_ids <- dbGetQuery(my_connection, 
  sprintf("SELECT customer_id FROM CUSTOMERS WHERE customer_id = '%s'"
          ,   df$customer_id[i]))
    if(nrow(existing_ids) > 0) {
      cat(sprintf("Skipping duplicate entry for customer_id: %s\n"
                  , df$customer_id[i]))
      next
    }
     
    insert_query <- sprintf("INSERT INTO CUSTOMERS (customer_id, first_name
    , last_name, username, gender, date_of_birth, email, phone, street_name
    , city, country, zip_code, account_created_date, premium_subscription)
    VALUES ('%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s'
    , '%s', '%s', %d)",
    df$customer_id[i], df$first_name[i], df$last_name[i], df$username[i]
    , df$gender[i], df$date_of_birth[i],df$email[i], df$phone[i]
    , df$street_name[i], df$city[i], df$country[i], df$zip_code[i]
    , df$account_created_date[i], df$premium_subscription[i])
    tryCatch({
dbExecute(my_connection, insert_query)
  cat(sprintf("Successfully inserted row: %d\n", i))
}, error = function(e) {
  cat(sprintf("Error in inserting row: %d, Error: %s\n", i, e$message))
})
  }

  # Close the database connection
  dbDisconnect(my_connection)
}

for(file in customer_files) {
  df <- readr::read_csv(file)
  ingest_customer_data(df)
  
}

```

```{r}
my_connection <- RSQLite::dbConnect(RSQLite::SQLite()
                                    , "database/ecommerce_database_v1.db")
dbGetQuery(my_connection,"SELECT * FROM CUSTOMERS;")
```


2. PRODUCT_CATEGORY 

```{r}
ingest_product_category <- function(df) {
  
  my_connection <- RSQLite::dbConnect(RSQLite::SQLite()
                                      , "database/ecommerce_database_v1.db")

  # Check for null values in NOT NULL columns
  required_columns <- c("category_id", "cat_name")
  df <- df[!rowSums(is.na(df[required_columns])) > 0, ]
  
  # Insert validated data into the database
  for(i in 1:nrow(df)){
    # Check for duplicate records based on the primary key
    existing_ids <- dbGetQuery(my_connection, sprintf("SELECT category_id 
            FROM PRODUCT_CATEGORY WHERE category_id = '%s'", df$category_id[i]))
    if(nrow(existing_ids) > 0) {
      cat(sprintf("Skipping duplicate entry for category_id: %s\n"
                  , df$category_id[i]))
      next
    }
    
    insert_query <- sprintf("INSERT INTO PRODUCT_CATEGORY 
                            (category_id, cat_name) VALUES ('%s', '%s')",
                            df$category_id[i], df$cat_name[i])
    tryCatch({
      dbExecute(my_connection, insert_query)
      cat(sprintf("Successfully inserted row: %d\n", i))
    }, error = function(e) {
      cat(sprintf("Error in inserting row: %d, Error: %s\n", i, e$message))
    })
  }
  
    dbDisconnect(my_connection)

}

for(file in category_files) {
  
  df <- readr::read_csv(file)
  ingest_product_category(df)
}

```


```{r}
my_connection <- RSQLite::dbConnect(RSQLite::SQLite()
                                    , "database/ecommerce_database_v1.db")
dbGetQuery(my_connection,"SELECT * FROM PRODUCT_CATEGORY;")
```


SUPPLIERS

```{r}
ingest_suppliers <- function(df) {
  
  my_connection <- RSQLite::dbConnect(RSQLite::SQLite()
                                      , "database/ecommerce_database_v1.db")

  # Email format validation
  valid_email <- grepl("^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
                       , df$supplier_email)
  df <- df[valid_email, ]
  
  # Check for null values in NOT NULL columns
  required_columns <- c("supplier_id", "supplier_name")
  df <- df[!rowSums(is.na(df[required_columns])) > 0, ]
  
  for(i in 1:nrow(df)){
    # Check for duplicate records based on the primary key
    existing_supplier_ids <- dbGetQuery(my_connection, sprintf("SELECT 
      supplier_id FROM SUPPLIERS WHERE supplier_id = '%s'", df$supplier_id[i]))
    if(nrow(existing_supplier_ids) > 0) {
      cat(sprintf("Skipping duplicate entry for supplier_id: %s\n"
                  , df$supplier_id[i]))
      next
    }
    
    insert_query <- sprintf("INSERT INTO SUPPLIERS (supplier_id, supplier_name
      , supplier_address, supplier_phone, supplier_email) 
      VALUES ('%s', '%s', '%s', '%s', '%s')",
                            df$supplier_id[i], df$supplier_name[i], 
      df$supplier_address[i], df$supplier_phone[i], df$supplier_email[i])
    tryCatch({
      dbExecute(my_connection, insert_query)
      cat(sprintf("Successfully inserted row: %d\n", i))
    }, error = function(e) {
      cat(sprintf("Error in inserting row: %d, Error: %s\n", i, e$message))
    })
    
  }
    dbDisconnect(my_connection)

}

for(file in suppliers_files) {
  
  df <- readr::read_csv(file)
  ingest_suppliers(df)
  
}

```

GIFT CARDS

```{r}

ingest_gift_card_data <- function(df) {
  
  my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")

  # Validate 'gift_card_id' and 'gift_card_code' for null values
  required_columns <- c("gift_card_id", "gift_card_code", "status")
  df <- df[!rowSums(is.na(df[required_columns])) > 0, ]
  
  # Ensure 'detail' is an integer
  df$detail <- as.numeric(df$detail)
  
  # Insert validated data into the database
  for(i in 1:nrow(df)){
    # Check for duplicate records based on the primary key
    existing_ids <- dbGetQuery(my_connection, sprintf("SELECT gift_card_id FROM GIFT_CARD WHERE gift_card_id = '%s'", df$gift_card_id[i]))
    if(nrow(existing_ids) > 0) {
      cat(sprintf("Skipping duplicate entry for gift_card_id: %s\n", df$gift_card_id[i]))
      next
    }
    
    insert_query <- sprintf("INSERT INTO GIFT_CARD (gift_card_id, gift_card_code, detail, status) VALUES ('%s', '%s', %f, '%s')",
                            df$gift_card_id[i], df$gift_card_code[i], df$detail[i], df$status[i])
    tryCatch({
      dbExecute(my_connection, insert_query)
      cat(sprintf("Successfully inserted row: %d\n", i))
    }, error = function(e) {
      cat(sprintf("Error in inserting row: %d, Error: %s\n", i, e$message))
    })
  }
    dbDisconnect(my_connection)

}

for(file in gift_card_files) {
  
  df <- readr::read_csv(file)
  ingest_gift_card_data(df)
  
}

```

```{r}
my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
dbGetQuery(my_connection,"SELECT * FROM GIFT_CARD;")
```

PRODUCTS

```{r}
ingest_products <- function(df) {
  
  my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
  # Data type checks
  df$stock_quantity <- as.integer(df$stock_quantity)
  
  # Check for null values in NOT NULL columns
  required_columns <- c("product_id", "stock_quantity", "category_id", "supplier_id")
  df <- df[!rowSums(is.na(df[required_columns])) > 0, ]
  
  for(i in 1:nrow(df)){
    # Check for duplicate records based on the primary key and foreign key constraints
    existing_product_ids <- dbGetQuery(my_connection, sprintf("SELECT product_id FROM PRODUCTS WHERE product_id = '%s'", df$product_id[i]))
    if(nrow(existing_product_ids) > 0) {
      cat(sprintf("Skipping duplicate entry for product_id: %s\n", df$product_id[i]))
      next
    }
    
    # Construct and execute the insertion query
    insert_query <- sprintf("INSERT INTO PRODUCTS (product_id, product_name, price, stock_quantity, category_id, supplier_id) VALUES ('%s', '%s', %f, %d, '%s', '%s')",
                            df$product_id[i], df$product_name[i], df$price[i], df$stock_quantity[i], df$category_id[i], df$supplier_id[i])
    tryCatch({
      dbExecute(my_connection, insert_query)
      cat(sprintf("Successfully inserted row: %d\n", i))
    }, error = function(e) {
      cat(sprintf("Error in inserting row: %d, Error: %s\n", i, e$message))
    })
  }
    dbDisconnect(my_connection)

}

for(file in products_files) {
  
  df <- readr::read_csv(file)
  ingest_products(df)
  
}

```

```{r}
my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
dbGetQuery(my_connection,"SELECT * FROM PRODUCTS;")
```


ORDER

```{r}
ingest_orders <- function(df) {
  
  my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")

  # Essential columns for validation
  required_columns <- c("order_id", "order_status", "quantity")
  df <- df[!rowSums(is.na(df[required_columns])) > 0, ]
  
  for(i in 1:nrow(df)) {
    # Check for duplicate order_id
    existing_ids <- dbGetQuery(my_connection, sprintf("SELECT order_id FROM ORDERS WHERE order_id = '%s'", df$order_id[i]))
    if(nrow(existing_ids) > 0) {
      cat(sprintf("Skipping duplicate entry for order_id: %s\n", df$order_id[i]))
      next
    }

    # Data validation for quantity
    if(!is.numeric(df$quantity[i]) || df$quantity[i] <= 0) {
      cat(sprintf("Skipping entry due to invalid quantity for order_id: %s\n", df$order_id[i]))
      next
    }

    # Insert validated data into the database
    insert_query <- sprintf("INSERT INTO ORDERS (order_id, customer_id, product_id, shipment_id, gift_card_id, payment_method, quantity, order_timestamp, payment_timestamp, order_status) VALUES ('%s', '%s', '%s', '%s', '%s', '%s', %d, '%s', '%s', '%s')",
                            df$order_id[i], df$customer_id[i], df$product_id[i], df$shipment_id[i], df$gift_card_id[i], df$payment_method[i], df$quantity[i], df$order_timestamp[i], df$payment_timestamp[i], df$order_status[i])
    tryCatch({
      dbExecute(my_connection, insert_query)
      cat(sprintf("Successfully inserted row: %d\n", i))
    }, error = function(e) {
      cat(sprintf("Error in inserting row: %d, Error: %s\n", i, e$message))
    })
  }
    dbDisconnect(my_connection)

}


# Assume orders_df is your DataFrame containing orders data
ingest_orders(orders_df)


```


```{r}
my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
dbGetQuery(my_connection,"SELECT * FROM ORDERS;")
```


SHIPMENTS

```{r}
ingest_shipment_data <- function(df) {
  
  my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
  # Validate 'shipment_id' and 'status' for null values
  required_columns <- c("shipment_id", "status")
  df <- df[!rowSums(is.na(df[required_columns])) > 0, ]
  
  # Convert timestamps to appropriate format
 #df$dispatch_timestamp <- ifelse(is.na(df$dispatch_timestamp), "", df$dispatch_timestamp)
  #df$delivered_timestamp <- ifelse(is.na(df$delivered_timestamp), "", df$delivered_timestamp)
  
  # Insert validated data into the database
  for(i in 1:nrow(df)){
    # Check for duplicate records based on the primary key
    existing_ids <- dbGetQuery(my_connection, sprintf("SELECT shipment_id FROM SHIPMENT WHERE shipment_id = '%s'", df$shipment_id[i]))
    if(nrow(existing_ids) > 0) {
      cat(sprintf("Skipping duplicate entry for shipment_id: %s\n", df$shipment_id[i]))
      next
    }
    
    insert_query <- sprintf("INSERT INTO SHIPMENT (shipment_id, dispatch_timestamp, delivered_timestamp, status) VALUES ('%s', '%s', '%s', '%s')",
                            df$shipment_id[i], df$dispatch_timestamp[i], df$delivered_timestamp[i], df$status[i])
    tryCatch({
      dbExecute(my_connection, insert_query)
      cat(sprintf("Successfully inserted row: %d\n", i))
    }, error = function(e) {
      cat(sprintf("Error in inserting row: %d, Error: %s\n", i, e$message))
    })
  }
    dbDisconnect(my_connection)

}

ingest_shipment_data(shipment_df)
```



1. Top 10 Products - Overall (Quantity)
2. Top 5 Categories (Quantity)
3. Top 3 Products across categories (Total Amount)
```{r}
# Join orders with products to get category information
orders_with_category <- orders_df %>%
  inner_join(products_df, by = "product_id")

# Calculate total amount for each product
product_amounts <- orders_with_category %>%
  group_by(category_id, product_id, product_name) %>%
  summarise(total_amount = sum(quantity * price, na.rm = TRUE)) %>%
  ungroup()

# Join with category_df to get category names
product_amounts_with_category_name <- product_amounts %>%
  inner_join(category_df, by = "category_id")

# Get overall top 3 products
top_3_products <- product_amounts_with_category_name %>%
  arrange(desc(total_amount)) %>%
  slice_max(total_amount, n = 3) %>%
  ungroup()

# Plot using ggplot2
ggplot(top_3_products, aes(x = reorder(product_name, total_amount), y = total_amount, fill = cat_name)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  coord_flip() +
  labs(title = "Top 3 Products by Total Amount",
       x = "Product Name",
       y = "Total Amount") +
  theme_minimal() +
  theme(legend.title = element_text(size = 12),
        legend.text = element_text(size = 10))
```

<<<<<<< HEAD

=======
4. Average delivery time for orders across top 5 delivery suppliers
>>>>>>> d065673478773d9575d62ba440477f02d2d07c48

5. Top 20 Average Spending across customers
6. Top 20 cancelled orders for which category
7. Average number of orders across time
8. Scatter plot for revenue across quantity; color by category


```{r}
my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
dbGetQuery(my_connection,"SELECT * FROM SHIPMENT;")
```

<<<<<<< HEAD
=======
7. Average number of orders across time
8. Scatter plot for revenue across quantity; color by category

Foreign Key Check
ORDERS
customer_id check
```{r}
<<<<<<< HEAD
query_1 <- "
WITH product AS (
           SELECT 
=======
dbGetQuery(my_connection,
           "SELECT 
              DISTINCT o.customer_id as customer_id,
              c.customer_id as customer_id,
              first_name ||' '|| last_name as customer_name
           FROM ORDERS as o
           LEFT JOIN CUSTOMERS as c ON c.customer_id = o.customer_id
           ;")
```

product_id check
```{r}
dbGetQuery(my_connection,
           "SELECT 
              DISTINCT o.product_id as product_id,
              p.product_id as product_id,
              product_name as product_name
           FROM ORDERS as o
           LEFT JOIN PRODUCTS as p ON o.product_id = p.product_id
           ;")
```

gift_card_id
```{r}
dbGetQuery(my_connection,
           "SELECT 
              DISTINCT o.gift_card_id as gif_card_id,
              g.gift_card_id,
              gift_card_code
           FROM ORDERS as o
           LEFT JOIN GIFT_CARD as g ON g.gift_card_id = o.gift_card_id
           ;")
```

shipment_id
```{r}
dbGetQuery(my_connection,
           "SELECT 
              DISTINCT o.shipment_id as x,
              s.shipment_id
           FROM ORDERS as o
           LEFT JOIN SHIPMENT as s ON s.shipment_id = o.shipment_id
           ORDER BY o.shipment_id
           ;")
```

PRODUCTS
supplier_id
```{r}
dbGetQuery(my_connection,
           "SELECT 
              DISTINCT p.supplier_id,
              s.supplier_id as a,
              s.supplier_name
           FROM PRODUCTS as p
           LEFT JOIN SUPPLIERS as s ON p.supplier_id = s.supplier_id
           ORDER BY p.supplier_id
           ;")
```

category_id
```{r}
dbGetQuery(my_connection,
           "SELECT 
              DISTINCT p.category_id,
              c.category_id as c,
              cat_name
           FROM PRODUCTS as p
           LEFT JOIN PRODUCT_CATEGORY as c ON c.category_id = p.category_id
           ORDER BY p.category_id
           ;")
```


>>>>>>> 83af47df161d1718e6a3ffa8896826843d366024

SQL version

1. Top 10 Products - Overall (Quantity)
```{r}
# Define the SQL query
query_1 <- dbGetQuery(my_connection,
           "SELECT 
>>>>>>> 8f8f211fa739d06b12fbf27abfaa9d571080052f
              ORDERS.product_id,
              product_name,
              count(quantity) as total_purchase
           FROM ORDERS
           JOIN PRODUCTS ON ORDERS.product_id = PRODUCTS.product_id
           WHERE lower(order_status) in ('shipped','delivered')
           GROUP BY ORDERS.product_id,product_name
           ORDER BY total_purchase desc
           LIMIT 10
<<<<<<< HEAD
           
)
SELECT*FROM product
"
```

```{r}
#bar chart
top_10_products <- dbGetQuery(my_connection, query_1)

ggplot(top_10_products,aes(x=product_name,y=total_purchase, fill=product_name))+geom_bar(stat="identity")+labs(x="Product Name", y="Total Number of Purchase")+coord_flip()

=======
           ;")

# Visualize the result using ggplot2
ggplot(query_1, aes(x = reorder(product_name, total_amount), y = total_amount, fill = cat_name)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  coord_flip() +
  labs(title = "Top 3 Products by Total Amount",
       x = "Product Name",
       y = "Total Amount") +
  theme_minimal() +
  theme(legend.title = element_text(size = 12),
        legend.text = element_text(size = 10))
>>>>>>> 8f8f211fa739d06b12fbf27abfaa9d571080052f
```


2. Top 5 Categories (Quantity)
```{r}
# SQL query to fetch top 5 categories by quantity
query_2 <- dbGetQuery(my_connection,
           "SELECT 
              cat_name as category,
              count(quantity) as total_purchase
           FROM ORDERS
           JOIN PRODUCTS ON ORDERS.product_id = PRODUCTS.product_id
           JOIN PRODUCT_CATEGORY ON PRODUCTS.category_id = PRODUCT_CATEGORY.category_id
           WHERE lower(order_status) in ('shipped','delivered')
           GROUP BY cat_name
           ORDER by total_purchase desc
           LIMIT 5
           ;")

# Plot using ggplot2
ggplot(query_2, aes(x = reorder(category, total_purchase), y = total_purchase, fill = category)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  coord_flip() +
  labs(title = "Top 5 Categories by Quantity",
       x = "Category",
       y = "Quantity Sold") +
  theme_minimal() +
  theme(legend.title = element_text(size = 12),
        legend.text = element_text(size = 10))
```

2. Top 5 Categories (Quantity)
```{r}
# SQL query to fetch top 5 categories by quantity
query_2 <- "
WITH product AS (
    SELECT 
        PRODUCT_CATEGORY.cat_name AS category,
        COUNT(ORDERS.quantity) AS total_purchase
    FROM ORDERS
    JOIN PRODUCTS ON ORDERS.product_id = PRODUCTS.product_id
    JOIN PRODUCT_CATEGORY ON PRODUCTS.category_id = PRODUCT_CATEGORY.category_id
    WHERE LOWER(ORDERS.order_status) IN ('shipped', 'delivered')
    GROUP BY PRODUCT_CATEGORY.cat_name
    ORDER BY total_purchase DESC
    LIMIT 5
)
SELECT * FROM product
"
```

```{r}
# Execute the query and store the result in a data frame
top_categories_df <- dbGetQuery(my_connection, query_2)

# Plot using ggplot2
ggplot(top_categories_df, aes(x = reorder(category, total_purchase), y = total_purchase, fill = category)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  coord_flip() +
  labs(title = "Top 5 Categories by Quantity",
       x = "Category",
       y = "Quantity Sold") +
  theme_minimal() +
  theme(legend.title = element_text(size = 12),
        legend.text = element_text(size = 10))
```

3. Top 3 Products across categories (Total Amount)
```{r}
query_3 <- dbGetQuery(my_connection,
"SELECT
    pc.cat_name,
    p.product_name,
    SUM(o.quantity * p.price) AS total_amount
FROM ORDERS as o
JOIN PRODUCTS as p ON o.product_id = p.product_id
JOIN PRODUCT_CATEGORY as pc ON pc.category_id = p.category_id
WHERE LOWER(o.order_status) IN ('shipped', 'delivered')
GROUP BY p.product_id, pc.cat_name, p.product_name
ORDER BY total_amount DESC
LIMIT 3;")

# Plot using ggplot2
ggplot(query_3, aes(x = reorder(product_name, total_amount), y = total_amount, fill = cat_name)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  coord_flip() +
  labs(title = "Top 3 Products by Total Amount",
       x = "Product Name",
       y = "Total Amount") +
  theme_minimal() +
  theme(legend.title = element_text(size = 12),
        legend.text = element_text(size = 10))
```

4. Average delivery time for orders across top 5 delivery suppliers
```{r}
<<<<<<< HEAD
# Define the SQL query for average delivery time for orders across top 5 delivery suppliers
query_4 <- dbGetQuery(my_connection,
           "SELECT 
               sup.supplier_id,
               sup.supplier_name AS supplier_name,
               AVG(julianday(s.delivered_timestamp) - julianday(s.dispatch_timestamp)) AS delivery_time
           FROM SHIPMENT AS s
           JOIN ORDERS AS o ON o.shipment_id = s.shipment_id
           JOIN PRODUCTS AS p ON p.product_id = o.product_id
           JOIN SUPPLIERS AS sup ON sup.supplier_id = p.supplier_id  -- Adjusted this line
           WHERE LOWER(s.status) = 'delivered'
           GROUP BY sup.supplier_id, sup.supplier_name
           ORDER BY delivery_time DESC, supplier_name
           LIMIT 5;")

# Plot using ggplot2
ggplot(query_4, aes(x = reorder(supplier_name, average_delivery_time), y = average_delivery_time, fill = supplier_name)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(title = "Average Delivery Time for Delivery Suppliers",
=======
query_4 <- "
SELECT
    sup.supplier_name AS supplier_name,
    AVG(julianday(s.delivered_timestamp) - julianday(s.dispatch_timestamp)) AS average_delivery_time
FROM SHIPMENT AS s
JOIN ORDERS AS o ON o.shipment_id = s.shipment_id
JOIN PRODUCTS AS p ON p.product_id = o.product_id
JOIN SUPPLIERS AS sup ON sup.supplier_id = p.supplier_id
WHERE LOWER(s.status) = 'delivered'
GROUP BY sup.supplier_id, sup.supplier_name
ORDER BY average_delivery_time ASC
LIMIT 5
"
```

```{r}
# Execute the query and store the result in a data frame
top_delivery_df <- dbGetQuery(my_connection, query_4)

# Plot using ggplot2
ggplot(top_delivery_df, aes(x = reorder(supplier_name, average_delivery_time), y = average_delivery_time, fill = supplier_name)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(title = "Average Delivery Time for Top 5 Delivery Suppliers",
>>>>>>> e4cbaa3f596b2def96caf11c8ec3ca07379740e7
       x = "Supplier Name",
       y = "Average Delivery Time (Days)") +
  theme_minimal() +
  theme(legend.position = "none")
```

5. Top 20 Average Spending across customers
```{r}
# Define the SQL query
<<<<<<< HEAD
query_5 <- dbGetQuery(my_connection,
           "SELECT
              o.customer_id as customer_id,
              c.first_name ||' '|| c.last_name as customer_name,
              AVG(p.price*o.quantity) as avg_amount,
              SUM(p.price*o.quantity) as total_amount
            FROM ORDERS as o
            JOIN CUSTOMERS as c ON o.customer_id = c.customer_id
            JOIN PRODUCTS as p ON p.product_id = o.product_id
            WHERE LOWER(o.order_status) IN ('shipped', 'delivered')
            GROUP BY o.customer_id,customer_name
            ORDER BY avg_amount DESC
            limit 20
           ;")
=======
query_5 <- "
SELECT
    o.customer_id as customer_id,
    c.first_name || ' ' || c.last_name as customer_name,
    AVG(p.price * o.quantity) as avg_amount
FROM ORDERS as o
JOIN CUSTOMERS as c ON o.customer_id = c.customer_id
JOIN PRODUCTS as p ON p.product_id = o.product_id
WHERE LOWER(o.order_status) IN ('shipped', 'delivered')
GROUP BY o.customer_id, c.first_name, c.last_name
ORDER BY avg_amount DESC
LIMIT 20
"
```

```{r}
# Execute the query and store the result in a data frame
avg_spending_df <- dbGetQuery(my_connection, query_5)
>>>>>>> e4cbaa3f596b2def96caf11c8ec3ca07379740e7

# Plot using ggplot2
ggplot(avg_spending_df, aes(x = reorder(customer_name, avg_amount), y = avg_amount, fill = customer_name)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(title = "Top 20 Average Spending Across Customers",
       x = "Customer",
       y = "Average Spending") +
  theme_minimal() +
  theme(axis.title.x = element_text(face = "bold"),
        axis.title.y = element_text(face = "bold"),
        plot.title = element_text(hjust = 0.5, face = "bold"),
        legend.position = "none")
```

6. Top 20 cancelled orders for which category
```{r}
query_6 <- dbGetQuery(my_connection,
           "SELECT
              cat_name,
              COUNT(o.quantity) as total_cancelled
            FROM ORDERS as o
            JOIN PRODUCTS as p ON p.product_id = o.product_id
            JOIN PRODUCT_CATEGORY as pc on pc.category_id = p.category_id
            WHERE LOWER(order_status) = 'cancelled'
            GROUP BY cat_name
            ORDER BY total_cancelled DESC
           ;")

# Visualization
ggplot(cancelled_df, aes(x = reorder(cat_name, total_cancelled), y = total_cancelled, fill = cat_name)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(title = "Top 20 Cancelled Orders by Category",
       x = "Category Name",
       y = "Number of Cancelled Orders") +
  theme_minimal() +
  theme(legend.position = "none")
```

7. Average number of orders across time
```{r}

query_7 <- dbGetQuery(my_connection,
           "SELECT
              order_timestamp as date,
              SUM(o.quantity) as total_order
            FROM ORDERS as o
            WHERE LOWER(order_status) IN ('shipped', 'delivered')
            GROUP BY order_timestamp
            ORDER BY date
           ;")

```

```{r}
#Scatter plot
ggplot(query_7,aes(x=date,y=total_order,group=1))+geom_point(stat="identity")+geom_line(stat="identity")+labs(x="Date",y="Total Number of Order")+theme(axis.text.x=element_text(angle=35))

```



8. Scatter plot for revenue across quantity; color by category
```{r}

dbGetQuery(my_connection,
           "SELECT
              cat_name,
              SUM(o.quantity) as quantity,
              SUM(p.price * o.quantity) as amount
            FROM ORDERS as o
            JOIN PRODUCTS as p ON p.product_id = o.product_id
            JOIN PRODUCT_CATEGORY as pc on pc.category_id = p.category_id
            WHERE LOWER(order_status) IN ('shipped', 'delivered')
            GROUP BY cat_name
           ;")

ggplot(revenue_quantity, aes(x = quantity, y = amount, color = cat_name)) +
  geom_point() +
  theme_minimal() +
  labs(title = "Scatter Plot of Quantity vs Amount by Category",
       x = "Quantity",
       y = "Amount") +
  theme(legend.position = "right")

```




